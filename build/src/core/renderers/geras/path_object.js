/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import * as colour from '../../utils/colour.js';
import * as dom from '../../utils/dom.js';
import { Svg } from '../../utils/svg.js';
import { PathObject as BasePathObject } from '../common/path_object.js';
/**
 * An object that handles creating and setting each of the SVG elements
 * used by the renderer.
 */
export class PathObject extends BasePathObject {
    /**
     * @param root The root SVG element.
     * @param style The style object to use for colouring.
     * @param constants The renderer's constants.
     */
    constructor(root, style, constants) {
        super(root, style, constants);
        this.constants = constants;
        /**
         * The colour of the dark path on the block in '#RRGGBB' format.
         */
        this.colourDark = '#000000';
        /** The dark path of the block. */
        this.svgPathDark = dom.createSvgElement(Svg.PATH, {
            'class': 'blocklyPathDark',
            'transform': 'translate(1,1)',
        });
        // SVG draw order is based on the order of elements (top most = back most)
        // So we need to insert the dark path before the base path to make sure it
        // gets drawn first.
        this.svgRoot.insertBefore(this.svgPathDark, this.svgPath);
        /** The light path of the block. */
        this.svgPathLight = dom.createSvgElement(Svg.PATH, { 'class': 'blocklyPathLight' }, this.svgRoot);
    }
    setPath(mainPath) {
        this.svgPath.setAttribute('d', mainPath);
        this.svgPathDark.setAttribute('d', mainPath);
    }
    /**
     * Set the highlight path generated by the renderer onto the SVG element.
     *
     * @param highlightPath The highlight path.
     */
    setHighlightPath(highlightPath) {
        this.svgPathLight.setAttribute('d', highlightPath);
    }
    flipRTL() {
        // Mirror the block's path.
        this.svgPath.setAttribute('transform', 'scale(-1 1)');
        this.svgPathLight.setAttribute('transform', 'scale(-1 1)');
        this.svgPathDark.setAttribute('transform', 'translate(1,1) scale(-1 1)');
    }
    applyColour(block) {
        this.svgPathLight.style.display = '';
        this.svgPathDark.style.display = '';
        if (!this.style.colourTertiary) {
            throw new Error('The renderer did not properly initialize the tertiary colour of ' +
                'the block style');
        }
        this.svgPathLight.setAttribute('stroke', this.style.colourTertiary);
        this.svgPathDark.setAttribute('fill', this.colourDark);
        super.applyColour(block);
        this.svgPath.setAttribute('stroke', 'none');
    }
    setStyle(blockStyle) {
        this.style = blockStyle;
        this.colourDark =
            colour.blend('#000', this.style.colourPrimary, 0.2) || this.colourDark;
    }
    updateHighlighted(highlighted) {
        super.updateHighlighted(highlighted);
        if (highlighted) {
            this.svgPathLight.style.display = 'none';
        }
        else {
            this.svgPathLight.style.display = 'inline';
        }
    }
    updateShadow_(shadow) {
        if (shadow) {
            this.svgPathLight.style.display = 'none';
            if (!this.style.colourSecondary) {
                throw new Error('The renderer did not properly initialize the secondary colour ' +
                    'of the block style block style');
            }
            this.svgPathDark.setAttribute('fill', this.style.colourSecondary);
            this.svgPath.setAttribute('stroke', 'none');
            this.svgPath.setAttribute('fill', this.style.colourSecondary);
        }
    }
    updateDisabled_(disabled) {
        super.updateDisabled_(disabled);
        if (disabled) {
            this.svgPath.setAttribute('stroke', 'none');
        }
    }
}
//# sourceMappingURL=path_object.js.map